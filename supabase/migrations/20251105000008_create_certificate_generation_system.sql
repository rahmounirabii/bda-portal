-- Migration: Certificate Generation System
-- Date: 2025-11-05
-- Description: Automatic certificate generation upon exam completion

-- =============================================================================
-- STORAGE BUCKET FOR CERTIFICATES
-- =============================================================================

-- Note: Bucket creation handled separately or via Supabase dashboard
-- Required bucket: 'certificates' with public read access

-- =============================================================================
-- FUNCTION: Generate Certificate After Passing Exam
-- =============================================================================

CREATE OR REPLACE FUNCTION generate_certificate_after_exam()
RETURNS TRIGGER
SECURITY DEFINER
SET search_path = public
LANGUAGE plpgsql
AS $$
DECLARE
    v_quiz quizzes%ROWTYPE;
    v_user users%ROWTYPE;
    v_credential_id TEXT;
    v_expiry_date DATE;
    v_existing_cert UUID;
BEGIN
    -- Only proceed if exam was passed
    IF NEW.passed IS NOT TRUE THEN
        RETURN NEW;
    END IF;

    -- Only proceed if exam is completed
    IF NEW.completed_at IS NULL THEN
        RETURN NEW;
    END IF;

    -- Check if certificate already exists for this attempt
    SELECT id INTO v_existing_cert
    FROM user_certifications
    WHERE quiz_attempt_id = NEW.id;

    IF v_existing_cert IS NOT NULL THEN
        -- Certificate already generated
        RETURN NEW;
    END IF;

    -- Get quiz details
    SELECT * INTO v_quiz
    FROM quizzes
    WHERE id = NEW.quiz_id;

    -- Get user details
    SELECT * INTO v_user
    FROM users
    WHERE id = NEW.user_id;

    IF v_quiz.id IS NULL OR v_user.id IS NULL THEN
        RAISE NOTICE 'Quiz or user not found for attempt %', NEW.id;
        RETURN NEW;
    END IF;

    -- Generate credential ID
    v_credential_id := generate_credential_id(v_quiz.certification_type);

    -- Calculate expiry date (3 years from issue date)
    v_expiry_date := CURRENT_DATE + INTERVAL '3 years';

    -- Create certification record
    INSERT INTO user_certifications (
        user_id,
        certification_type,
        credential_id,
        quiz_attempt_id,
        issued_date,
        expiry_date,
        status,
        certificate_url,
        created_by
    ) VALUES (
        NEW.user_id,
        v_quiz.certification_type,
        v_credential_id,
        NEW.id,
        CURRENT_DATE,
        v_expiry_date,
        'active',
        NULL, -- Certificate PDF generated by backend service
        NEW.user_id
    );

    RAISE NOTICE 'Certificate generated: % for user %', v_credential_id, v_user.email;

    RETURN NEW;
END;
$$;

-- Grant execution permission
GRANT EXECUTE ON FUNCTION generate_certificate_after_exam() TO authenticated;
GRANT EXECUTE ON FUNCTION generate_certificate_after_exam() TO service_role;

COMMENT ON FUNCTION generate_certificate_after_exam() IS 'Automatically generates certificate record when user passes exam';

-- =============================================================================
-- TRIGGER: Auto-generate Certificate on Exam Completion
-- =============================================================================

DROP TRIGGER IF EXISTS trigger_generate_certificate ON quiz_attempts;

CREATE TRIGGER trigger_generate_certificate
    AFTER UPDATE OF passed, completed_at ON quiz_attempts
    FOR EACH ROW
    WHEN (NEW.passed IS TRUE AND NEW.completed_at IS NOT NULL)
    EXECUTE FUNCTION generate_certificate_after_exam();

COMMENT ON TRIGGER trigger_generate_certificate ON quiz_attempts IS 'Trigger certificate generation when exam is passed';

-- =============================================================================
-- FUNCTION: Get Certificate Details
-- =============================================================================

CREATE OR REPLACE FUNCTION get_certificate_details(p_credential_id TEXT)
RETURNS TABLE (
    credential_id TEXT,
    user_full_name TEXT,
    user_email TEXT,
    certification_type TEXT,
    issued_date DATE,
    expiry_date DATE,
    status TEXT,
    certificate_url TEXT,
    exam_title TEXT,
    exam_score INTEGER,
    exam_date TIMESTAMPTZ
)
SECURITY DEFINER
SET search_path = public
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    SELECT
        uc.credential_id,
        COALESCE(u.first_name || ' ' || u.last_name, u.email) as user_full_name,
        u.email as user_email,
        uc.certification_type::TEXT,
        uc.issued_date,
        uc.expiry_date,
        uc.status,
        uc.certificate_url,
        q.title as exam_title,
        qa.score as exam_score,
        qa.completed_at as exam_date
    FROM user_certifications uc
    JOIN users u ON u.id = uc.user_id
    LEFT JOIN quiz_attempts qa ON qa.id = uc.quiz_attempt_id
    LEFT JOIN quizzes q ON q.id = qa.quiz_id
    WHERE uc.credential_id = p_credential_id;
END;
$$;

GRANT EXECUTE ON FUNCTION get_certificate_details(TEXT) TO authenticated;
GRANT EXECUTE ON FUNCTION get_certificate_details(TEXT) TO anon; -- Public verification

COMMENT ON FUNCTION get_certificate_details(TEXT) IS 'Retrieve certificate details for display or verification';

-- =============================================================================
-- FUNCTION: Verify Certificate
-- =============================================================================

CREATE OR REPLACE FUNCTION verify_certificate(p_credential_id TEXT)
RETURNS TABLE (
    is_valid BOOLEAN,
    status TEXT,
    holder_name TEXT,
    certification_type TEXT,
    issued_date DATE,
    expiry_date DATE,
    message TEXT
)
SECURITY DEFINER
SET search_path = public
LANGUAGE plpgsql
AS $$
DECLARE
    v_cert user_certifications%ROWTYPE;
    v_user users%ROWTYPE;
BEGIN
    -- Find certificate
    SELECT * INTO v_cert
    FROM user_certifications
    WHERE credential_id = p_credential_id;

    IF v_cert.id IS NULL THEN
        RETURN QUERY SELECT
            false,
            'not_found'::TEXT,
            NULL::TEXT,
            NULL::TEXT,
            NULL::DATE,
            NULL::DATE,
            'Certificate not found'::TEXT;
        RETURN;
    END IF;

    -- Get user details
    SELECT * INTO v_user
    FROM users
    WHERE id = v_cert.user_id;

    -- Check status
    IF v_cert.status != 'active' THEN
        RETURN QUERY SELECT
            false,
            v_cert.status,
            COALESCE(v_user.first_name || ' ' || v_user.last_name, v_user.email),
            v_cert.certification_type::TEXT,
            v_cert.issued_date,
            v_cert.expiry_date,
            'Certificate is ' || v_cert.status::TEXT;
        RETURN;
    END IF;

    -- Check expiry
    IF v_cert.expiry_date < CURRENT_DATE THEN
        -- Update status to expired
        UPDATE user_certifications
        SET status = 'expired'
        WHERE id = v_cert.id;

        RETURN QUERY SELECT
            false,
            'expired'::TEXT,
            COALESCE(v_user.first_name || ' ' || v_user.last_name, v_user.email),
            v_cert.certification_type::TEXT,
            v_cert.issued_date,
            v_cert.expiry_date,
            'Certificate has expired'::TEXT;
        RETURN;
    END IF;

    -- Valid certificate
    RETURN QUERY SELECT
        true,
        'active'::TEXT,
        COALESCE(v_user.first_name || ' ' || v_user.last_name, v_user.email),
        v_cert.certification_type::TEXT,
        v_cert.issued_date,
        v_cert.expiry_date,
        'Certificate is valid'::TEXT;
END;
$$;

GRANT EXECUTE ON FUNCTION verify_certificate(TEXT) TO authenticated;
GRANT EXECUTE ON FUNCTION verify_certificate(TEXT) TO anon; -- Public verification

COMMENT ON FUNCTION verify_certificate(TEXT) IS 'Public certificate verification endpoint';

-- =============================================================================
-- FUNCTION: Get User Certificates
-- =============================================================================

CREATE OR REPLACE FUNCTION get_user_certificates(p_user_id UUID)
RETURNS TABLE (
    id UUID,
    credential_id TEXT,
    certification_type TEXT,
    status TEXT,
    issued_date DATE,
    expiry_date DATE,
    certificate_url TEXT,
    exam_title TEXT,
    exam_score INTEGER,
    is_expiring_soon BOOLEAN
)
SECURITY DEFINER
SET search_path = public
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    SELECT
        uc.id,
        uc.credential_id,
        uc.certification_type::TEXT,
        uc.status,
        uc.issued_date,
        uc.expiry_date,
        uc.certificate_url,
        q.title as exam_title,
        qa.score as exam_score,
        (uc.expiry_date - CURRENT_DATE) <= 60 AND (uc.expiry_date - CURRENT_DATE) > 0 as is_expiring_soon
    FROM user_certifications uc
    LEFT JOIN quiz_attempts qa ON qa.id = uc.quiz_attempt_id
    LEFT JOIN quizzes q ON q.id = qa.quiz_id
    WHERE uc.user_id = p_user_id
    ORDER BY uc.issued_date DESC;
END;
$$;

GRANT EXECUTE ON FUNCTION get_user_certificates(UUID) TO authenticated;

COMMENT ON FUNCTION get_user_certificates(UUID) IS 'Get all certificates for a user';

-- =============================================================================
-- FUNCTION: Update Certificate URL
-- =============================================================================

CREATE OR REPLACE FUNCTION update_certificate_url(
    p_credential_id TEXT,
    p_certificate_url TEXT
)
RETURNS BOOLEAN
SECURITY DEFINER
SET search_path = public
LANGUAGE plpgsql
AS $$
BEGIN
    UPDATE user_certifications
    SET certificate_url = p_certificate_url,
        updated_at = NOW()
    WHERE credential_id = p_credential_id;

    RETURN FOUND;
END;
$$;

GRANT EXECUTE ON FUNCTION update_certificate_url(TEXT, TEXT) TO authenticated;
GRANT EXECUTE ON FUNCTION update_certificate_url(TEXT, TEXT) TO service_role;

COMMENT ON FUNCTION update_certificate_url(TEXT, TEXT) IS 'Update certificate PDF URL after generation';

-- =============================================================================
-- STORAGE BUCKET POLICIES (To be executed in Supabase Dashboard or via API)
-- =============================================================================

-- Required Bucket: 'certificates'
-- Policy: Public read access for certificate verification
-- Policy: Authenticated users can read their own certificates
-- Policy: Service role can upload certificates

-- Example RLS policies (adjust as needed):
-- CREATE POLICY "Public can read certificates"
--   ON storage.objects FOR SELECT
--   USING (bucket_id = 'certificates');

-- CREATE POLICY "Service role can upload certificates"
--   ON storage.objects FOR INSERT
--   WITH CHECK (bucket_id = 'certificates' AND auth.role() = 'service_role');

-- =============================================================================
-- INDEXES FOR PERFORMANCE
-- =============================================================================

-- Certificate lookup by credential_id (already exists from previous migration)
-- CREATE INDEX IF NOT EXISTS idx_user_certifications_credential ON user_certifications(credential_id);

-- Certificate lookup by quiz_attempt_id
CREATE INDEX IF NOT EXISTS idx_user_certifications_attempt ON user_certifications(quiz_attempt_id);

-- =============================================================================
-- AUDIT TRAIL INTEGRATION
-- =============================================================================

-- Add 'certificate_generated' event type if not exists
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM pg_enum
        WHERE enumlabel = 'certificate_generated'
        AND enumtypid = (SELECT oid FROM pg_type WHERE typname = 'audit_event_type')
    ) THEN
        ALTER TYPE audit_event_type ADD VALUE 'certificate_generated';
    END IF;
END $$;

-- =============================================================================
-- EMAIL NOTIFICATION FOR CERTIFICATE
-- =============================================================================

-- Note: Email templates are defined in the get_email_template() function
-- in the email notification system migration, not in a separate table.
-- The certificate_issued template should be added to that function if needed.

-- =============================================================================
-- VERIFICATION
-- =============================================================================

SELECT 'âœ… Certificate generation system created successfully!' as status;

-- Test queries:
-- SELECT * FROM user_certifications ORDER BY created_at DESC LIMIT 5;
-- SELECT verify_certificate('CP-2025-0001');
-- SELECT * FROM get_certificate_details('CP-2025-0001');
